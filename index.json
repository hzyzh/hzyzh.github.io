
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":null,"categories":null,"content":"I’m going to pursue my PhD degree in Computer Science at Ohio State University in August, 2023. My research interests focus on Programming Language, hardware and software analysis, and my research advisor will be prof. Michael Bond. I receive my Bachelor’s degree in CS from Nanjing University in 2023, under the supervision of prof. Yu Wang.\n","date":1669075200,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1669075200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I’m going to pursue my PhD degree in Computer Science at Ohio State University in August, 2023. My research interests focus on Programming Language, hardware and software analysis, and my research advisor will be prof.","tags":null,"title":"Zeyu Huang","type":"authors"},{"authors":null,"categories":["Lecture notes"],"content":"$\\lambda$-Calculus $\\alpha$-evquivalence ​$\\lambda x.M =_{\\alpha}\\lambda y.M[y/x]$, y fresh\nfixpoint fixpoint combinator ​\t​\t$\\therefore$ fact = $\\Theta$ F\ntyped $\\lambda$ calculus ","date":1671813124,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1671813124,"objectID":"adf9fddf81b719090bd0b51df2a722e2","permalink":"https://hzyzh.github.io/post/notes-formalsemantics/","publishdate":"2022-12-23T16:32:04Z","relpermalink":"/post/notes-formalsemantics/","section":"post","summary":"$\\lambda$-Calculus $\\alpha$-evquivalence ​$\\lambda x.M =_{\\alpha}\\lambda y.M[y/x]$, y fresh\nfixpoint fixpoint combinator ​\t​\t$\\therefore$ fact = $\\Theta$ F\ntyped $\\lambda$ calculus ","tags":["Lecture notes","CS","Formal semantics","Programming Language"],"title":"formal semantics","type":"post"},{"authors":["Zhiluo Chen","Zeyu Huang","Yukang Zhou"],"categories":null,"content":"","date":1669075200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1669075200,"objectID":"f57e6bb82fed1a354bbaaaca4196a1a2","permalink":"https://hzyzh.github.io/publication/predicting-stock-trend-using-gnn/","publishdate":"2022-11-22T00:00:00Z","relpermalink":"/publication/predicting-stock-trend-using-gnn/","section":"publication","summary":"In stock market, numerous ways have been used to predict the future asset return. Traditional time series models and neural network models are both popular in practice. Many of them have been shown that they do not make full use of the property of long-term dependency while with the help of graph structure, one can turn time series into complex network and keep the long-term dependency property. To make use of the property of the long memory of financial market in prediction, our framework first applies the visibility method to turn stock price data into graph structure, and then applies graph neural network to make graph classification task to let the network learn the overall topological structure of the graphs. The result shows that with the use of such property, our model can successfully forecast the future stock trend.","tags":[],"title":"Predicting stock trend using GNN","type":"publication"},{"authors":null,"categories":["Lecture notes"],"content":"Ch. 2 白盒测试 vs 黑盒测试 白盒测试 允许测试人员利用程序内部的逻辑结构设计测试用例，对程序所有逻辑路径进行测试。\n测试对象基于被测试程序的源代码\n白盒测试方法必须遵循以下原则 保证一个模块中的所有独立路径至少被测试一次。 对所有的逻辑判定均需测试取真和取假两种情况。 在上下边界及可操作范围内运行所有循环。 检查程序的内部数据结构，保证其结构的有效性 白盒测试类别 静态测试： 不要求在计算机上实际执行所测试的程序，主要以一些人工的模拟技术对软件进行分析和测试，如代码检查法、静态结构分析法等；\n动态测试： 是通过输入一组预先按照一定的测试准则构造实际数据来动态运行程序，达到发现程序错误的过程。白盒测试中的动态分析技术主要有逻辑覆盖法和基本路径测试法。\n代码结构覆盖 修改决策条件覆盖？ 黑盒测试 完全不考虑程序的内部结构和处理过程的前提下，只基于规格说明来设计测试用例；又称为功能测试\n等价类划分 \u0026amp; 边界值分析 等价类划分：如所有符合要求的输入一类；针对违反不同规则的输入 各一类\nCategory Partition 一个程序有许多相关属性（attribute），如程序运行的：parameters，environment objects等（根据规格说明，将程序分解为若干功能单元functional unit）；\n针对每个attribute，分出若干个categories（如对于字符串长度，分为0，1，若干，超长。。。等）；\ngenerate test cases\n因果图和决策表 等价类划分和边界值分析都只孤立地考虑各个输入数据，而没有考虑多个输入数据间的组合效应，可能会遗漏了输入数据易于出错的组合情况\n因果图可以转化为决策表，表中每一列展示了原因和结果之间的关系。可以基于决策表设计对应的测试用例（例如，为表中的每一列设计一条测试用例）\n如：因果图，\n对应决策表\nCh. 3 软件开发中的测试方法 单元测试 Unit testing 与系统一个单一功能（logical purpose）有关的代码称为一个unit；\n编写一小段代码 =\u0026gt; 测试一个很小、很明确的功能正确\n快速执行\n自动化\n使用单元测试的自动化框架来自动执行单元测试用例：JUnit，NUnit，TestNG。。。 会自动设置测试环境、前置条件；自动执行测试用例；对比输出 集成测试 Integration Testing 在单元测试的基础上，采用适当的策略将已通过测试的模块组装成子系统或系统，并确保各模块组合到一起后能按既定的设计要求运行\n基于分解的集成（Decomposition-based） 自底向上（先开发底层模块）：先从原子模块开始，逐步向上组装和测试；需要 **测试驱动程序（driver）**来调用和协调各原子模块 自顶向下（先开发主控制模块）：则需要 **桩程序（stub）**和 模拟程序（mock） 混合策略（sandwich）：中上层自顶向下；中下层自底向上；灵活 基于功能集成：每次集成提供一个用户可感知的具体功能\n系统测试 System Testing 将整个软件系统视为一个整体来进行测试\n冒烟测试 Smoke Test 在每日构建完成后，对系统的基本功能进行简单的测试，是将代码更改签入到代码库之前的验证过程\ndaily build（从头到尾编译、链接、运行一次） + smoke test （简单的测试）\n回归测试 Regression Testing 代码修改后，重新进行测试以确认修改的正确性，以及修改没有引入新的错误\n回归测试通常要求自动化，以此来降低软件开发和维护成本 软件开发的各个阶段都会进行多次回归测试，新版本的连续发布会使回归测试进行的更加频繁（通常每天都需要进行若干次回归测试） 回归测试会对已有的测试用例库进行增删或改进 Flaky Test 在相同代码版本上，多次执行同一个测试用例却观察到不同的测试结果(可能因为测试用例引入了一些随机性？)\nFlakiness 的来源 (及解决方案) 并发和同步相关的问题 (e.g., test makes an asynchronous call and does not wait, multiple threads interact, …) 多条测试用例执行时的顺序和依赖问题 (e.g., shared variables, no cleaning up, …) 数据和资源的管理与控制问题 (e.g., database connections, memory allocations, unordered collections, …) 测试执行时间过⻓或难于控制、依赖于当前系统时间 (e.g., network, …) 随机性 (e.g., random numbers generator, …） Alpha 测试 在开发环境或模拟的实际操作环境下进行的测试（通常依赖第三方测试机构）\nBeta 测试 由软件用户在实际使用环境下进行的测试 (开发者无法控制测试环境)\nPerpetual Beta 软件系统长期处于Beta测试中\nCh4. 软件特性和方面的测试方法 针对软件效率的测试 对于一些大规模的复杂软件系统 (Ultra Large-Scale Software Systems)，针对软件运行效率的测试非常重要\n负载测试 Load Testing：检测系统在不同负载（concurrent users？）下的表现\n评估系统在不同工作量下的行为；有些问题可能需要在高负载下显现（memory leak，deadlock等） 压力测试 Stress Testing：检测系统在极限情况下的表现\n通过模拟负载，使系统在负载饱和或资源匮乏的状态下运行 软件老化 (Aging) 缺陷：软件系统⻓时间运行中出现的可用资源不足、性能下降、失效率增加等现象 (⻓时间运行后性能下降)，通常是由于系统状态中的错误累计和系统资源 (例如，物理内存、文件等) 的消耗造成的 通过⻓时间提供大量工作负载(例如，大量客户端请求) 使软件老化现象更快暴露出来 容量测试 Volume：检测系统在大数据量或大量用户下的表现\n通常只关注大容量，不关注实际使用 性能测试 Performance：评估系统的性能指标\n评估一堆性能指标 前仨面向缺陷；性能测试则面向指标\n可靠性测试 Reliability Testing：评估软件的可靠性程度；\n软件可靠性是指软件在规定的时间和规定的环境下，完成规定功能的能力\n看看ppt！\n安全性测试 检测软件安全控制机制的正确性和有效性\n安全功能测试：测试软件实现是否与安全需求说明一致 安全漏洞测试： 安全性测试中的常用方法 静态分析\n针对特定的攻击方式进行检查，尽早发现错误 存在误报和漏报现象，需要在两者之间进行平衡 形式化方法 (e.g., Model Checking)\n具有完备的数学基础，能对形式化的规格说明进行正确性证明 开发成本高，状态爆炸问题 模糊测试 Fuzzing\n语法测试 Syntax Testing\n用户认证+授权测试 （见ppt）\n兼容性测试 检测软件能否在不同的硬件平台、操作系统和网络环境之上、以及不同的应用之间正常运行\n配置测试 Configuration Testing：检测软件在不同构建和运行配置下是否能正常工作\n高可配置软件：允许用户定义一系列配置选项而保持核心功能不变 可能存在解空间爆炸的问题（一堆可选配置的组合） 图形用户界面测试GUI （每个用户操作 可能出发不同event）\n基于模型的测试：定义coverage概念\nEvent Flow Graph（EFG）：每个点代表event，边代表一个用户操作 cover nodes and edges；sequences of events Finite State Machine（FSM）：node代表一个界面/窗口？edge代表一个event 软件测试坐标系：\nCh5. Random Testing problem：测试空间太大，无法全测\nissues in RT：\nnumber好randomly sample，但复杂数据结构如何随机sample？（还有内存、时间限制） RT sample的质量：diversity！\nAdaptive Random Testing (ART) Select test cases that are as diverse as possible:\n可以尝试 maximize distance between tests 几种implementations：\nFixed-Size-Candidate-Set (FSCS)\nPartition based-ART\nevaluate the distribution of a given test set: distribution metric\ndiscrepency:\ndispersion:\ndiversity:\nART Weaknesses: 计算复杂度 Boundary effect：更容易找到一堆边界处的test（实际不需要这么多） 高维效果差 Combinatorial Testing 全部测试开销过高；且并非所有的输入参数都与fault有关 =\u0026gt; 把fixed number t个不同参数的任意种组合情况都测试了，t就叫该测试的coverage strength\n一个例子：\nCT测试步骤\n如何depict input space很关键！\n（如要测试find命令）：\nCT的优点 t-way CT覆盖了小于等于t个参数的所有种interaction （exhaustive）；比穷举少多了 不过随着t增大，covering array大小显著提升！ 研究证明：绝大部分fault的产生所需interaction很少 Covering Array 不同参数可能有不同的value domains =\u0026gt; Mixed Covering Array\nSequence Covering Array：\n用于测试event顺序带来的影响，如： 构造 t-way covering array 构造minimal t-way CA是一个NP Hard的问题！一些简化方法：\nmathematical approach orthogonal array (OA) 得到最优的CA，但limited for certain problem instances greedy approach In-Parameter-Order (IPO) algorithm 运行效率高，但结果不一定最优 search-based approach 得到尽可能small的array，但高计算开销 CT的一些constraints hard constraint：并非所有parameter组合都有效（有些parameter不能同时出现）\nsoft constraint：测试者认为某些parameter组合没有必要测试\n得到t-way constrained covering array，要求：\nCA中每一行都满足约束；任意t个参数之间 满足约束 的组合至少出现一次 会引入隐性约束问题：如有约束：(P1=0,P2=0),(P2=1,P3=1) =\u0026gt; (P1=0,P3=1) constraint solver：用来检测一个（partial）test case是否valid\n将所有constraints表达式用solver支持的形式表示：如boolean formula SAT/SMT FSM Testing model-based testing：建模，将原系统 map 为一个model；是一种reduction，model仅反应系统的部分性质\n根据model生成一些abstract test cases =\u0026gt; executable test cases\nstrongly connected：可以从FSM的任意状态s1转移到任意状态s2 一般假设：FSM M …","date":1664272946,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664272946,"objectID":"3069e6f67987e1f0d372e6e52b8d754d","permalink":"https://hzyzh.github.io/post/notes-softwaretesting/","publishdate":"2022-09-27T10:02:26Z","relpermalink":"/post/notes-softwaretesting/","section":"post","summary":"Ch. 2 白盒测试 vs 黑盒测试 白盒测试 允许测试人员利用程序内部的逻辑结构设计测试用例，对程序所有逻辑路径进行测试。\n测试对象基于被测试程序的源代码\n白盒测试方法必须遵循以下原则 保证一个模块中的所有独立路径至少被测试一次。 对所有的逻辑判定均需测试取真和取假两种情况。 在上下边界及可操作范围内运行所有循环。 检查程序的内部数据结构，保证其结构的有效性 白盒测试类别 静态测试： 不要求在计算机上实际执行所测试的程序，主要以一些人工的模拟技术对软件进行分析和测试，如代码检查法、静态结构分析法等；\n动态测试： 是通过输入一组预先按照一定的测试准则构造实际数据来动态运行程序，达到发现程序错误的过程。白盒测试中的动态分析技术主要有逻辑覆盖法和基本路径测试法。\n代码结构覆盖 修改决策条件覆盖？ 黑盒测试 完全不考虑程序的内部结构和处理过程的前提下，只基于规格说明来设计测试用例；又称为功能测试\n等价类划分 \u0026 边界值分析 等价类划分：如所有符合要求的输入一类；针对违反不同规则的输入 各一类\nCategory Partition 一个程序有许多相关属性（attribute），如程序运行的：parameters，environment objects等（根据规格说明，将程序分解为若干功能单元functional unit）；","tags":["Lecture notes","CS","Software Testing"],"title":"Software Testing","type":"post"},{"authors":null,"categories":["Lecture notes"],"content":"Ch2. 搜索 OPEN, CLOSED列表：OPEN记录待搜索结点；CLOSED记录已搜索结点\n最佳优先搜索 定义一个启发式算法：按照一定启发式函数 对每个OPEN结点排序；按顺序在OPEN中搜索\nA* 算法 每个节点的优先级：$f(n)=g(n)+h(n)$\n$f(n)$，n的综合优先级；$g(n)$，n距离起点的代价（bfs）；$h(n)$，n距离终点的预计代价，启发函数！ 若$h(n)$始终=0，则退化为了Dijkstra算法； 若$h(n)$始终\u0026lt;=节点n到终点的代价，则A*算法保证能找到最优路径！ Ch4. 知识表示 常见知识表示方法：\n一阶谓词表示 产生式表示 语义网络表示 框架表示 脚本表示 一阶谓词表示 产生式表示 例子：若ppp 则qqq\n​\tP$\\to$Q 或 IF P THEN Q （产生式）\n​\t产生式可以是不精确的，有可信度；而一阶谓词的蕴含式是非真即假的\n基本流程\u0026amp;结构 专家系统：不断从规则库中选择可应用的规则，并将得到的新事实加入到数据库（有事实驱动 和 目标驱动 两种）\n本质是 深度优先搜索 语义网络表示 结构/形式：有向图，定点表示概念，边 表示概念间语义关系。如图：\n边 有多种类别，可表示不同种类的关系，如：类属关系（ISA，member-of，kind-of），包含/聚类关系（part-of），属性关系（have，can），时间、位置、相似、推理关系等等，以及多元关系（一般是一元，如A$\\to$B） 推理：首先将待求解问题构造为网络片段（+查询点），然后根据原语义网络信息进行匹配得到解。如：\n问：陈家骏教授工作地点？ 知识图谱（语义关系简化了的语义网络？）被用于了搜索引擎、智能问答软件、社交网络（Facebook）中 存储和表示知识\n本质与谓词演算等价\n框架表示 表示形式 和 层级结构：框架名 、 槽名（描述某一方面属性） 、 侧面（描述属性的某一方面） 、 值\n向数据库的查询？ Ch5. 不确定性推理 例子：已知：“若电池或电缆有问题，则发动机不旋转且不亮” 是一条可靠知识\n则：“若发动机不转且不量，则电池或电缆有问题” 是一条不可靠知识！\n反绎推理（溯因推理） P$\\to$Q 和 Q： 有可能推出P（不确定）\n从不确定性初始事实，运用不确定性知识，获得不确定但合理的结论\n非单调推理 基于假设的推理，存在多条假设，并可以根据新证据排除/修正部分假设\nunless：p(x) unless q(x) $\\to$ r(x)：p(x)$\\to$q(x)为真，除非q(x)成立\n​\t若q(x)不知道是否为真，则可以先使用p(x)$\\to$q(x)\nis constent with：（M B(x) 意思为：没有证据表明 B(x)不成立/与现有证据矛盾） 真值维护系统TMS TMS实现机制：\n关联机制：将每条结论和理由 联系在一起； 定位机制：给定矛盾和理由，定位错误的假设 回收机制：收回错误假设 追溯机制：收回错误的假设的结论 理由网络： 封闭世界假设 只有求解问题需要的谓词，并且谓词的（定义域？）都是确定且封闭的：则若不含有p(X)为真，则not(p(X))为真\n确信度理论 MB(H|E)：给定证据E时，假设H的可信度量，取值范围[0,1] （\u0026gt;0说明E的出现提高了H出现的概率；否则=0）\nMD(H|E)：给定证据E时，假设H的不可信度量，取值范围[0,1]\n产生式规则一般形式：IF E THEN H $\\text{\\textcolor{red}{(CF(H|E)}}$)\nCF(H|E)为该条知识的确信度，CF(H|E) = MB(H|E) - MD(H|E) 同一证据不可能同时增加和降低H的可信度；MB和MD一定是互斥的（至多一个非0） 证据的不确定性：（也由确信度表示）\nCF(E) $\\in [-1,1]$ ：-1，证据E肯定为假； 1，E肯定为真； 0，对E一无所知 故 CF($\\neg$E) = -CF(E) 合取与析取 E=E1 and E2 and E3 and …，则 CF(E) = min{CF(E1), CF(E2), CF(E3), …} E=E1 or E2 or E3 or …，则 CF(E) = max{CF(E1), CF(E2), CF(E3), …} 注意与CF(H|E)的区别！(知识的不确定性) 不确定性的更新公式： CF(H) = CF(H|E) $\\times$ max{0, CF(E)}\n结论不确定性的合成：（多条知识算出的同一结论的确信度CF1(H)和CF2(H)，且知识的前提互相独立，则可以合成结论的综合确信度）\n信任函数 下限函数Bel：Bel(A) 表示对A的总信任度（即A为真的确信度）\n上限函数Pl：Pl(A)=1-Bel($\\neg$A) 表示A为非假的信任度\n对A信任程度的上下限：A[Bel(A), Pl(A)]； Pl(A)-Bel(A)对应“不知道” 的情况\n证据合并规则：\nCh6. 贝叶斯网络 概念：\n先验概率 vs 后验概率：先验，非条件概率，P(A)； 后验，条件概率，P(A|E)\n演绎推理 vs 归纳推理：演绎，不要求前件为真； 归纳，前件必须为真，但结论未必（从特殊到一般）\n贝叶斯定理：（全概率公式）$P(Hi|E)=\\frac{P(E|Hi)P(Hi)}{\\sum_{k}P(E|Hk)P(Hk)}$\n链式规则：$P(H|E1\\cap E2\\cap E3\\cap …\\cap En)=…$\n贝叶斯信念网络 顺序连接：\n分支连接：\n汇合连接：\nd-可分 节点A到B的路径中，若存在：\n顺序 / 分支连接 结构的中间节点已知 汇合连接 结构的中间节点及其所有子节点未知 则路径被阻断，A和B相互独立；否则A和B不相互独立\n变量的顺序是会影响建图结构的！ Ch7. 马尔可夫网络 有限状态系统{$s_1,s_2,…,s_n$}，离散时间点$t_i$下 对象所处状态记为$X_i$，满足：对象在t处所处状态的概率取决于时间1，2，…，t-1时的状态\n则一阶马尔科夫链满足：$P(X_t=s_k|X_{t-1},…,X_2,X_1)=P(X_t=s_k|X_{t-1})$\n马尔可夫逻辑网 （MLN） 变量消除 Ch8. 符号学习 概念学习 就是机器学习里的 二分类问题~\n决策树 ID3算法：ID3(Examples，Attributes)\n创建Root结点 基本情况：Examples中目标属性全为“+”/“-”，直接返回对应label的单结点树Root；若Attributes为空，则label设为Examples中最普遍的目标属性值 否则，找到Attributes中分类能力最好的属性A 作为Root的决策属性，并为A的每种可能取值 建立一个子树/叶子结点 选择最佳属性：\n熵：对于样本集合S，Entropy(S) = $\\sum_{i}-p_i\\log_2p_i$ ，熵越小越好（i为目标属性的所有可能取值，反映了集合S的混乱（不纯）程度！）\n信息增益： C4.5算法 先从候选划分属性中找出 信息增益 高于平均水平的属性，再从中选择 信息增益率 最高的\n信息增益率：信息增益 / 该属性的熵 = Gain(S, A) / IV(A) IV(A)= $-\\sum_{v\\in \\text{Values}(A)}\\frac{|S_v|}{|S|}\\log\\frac{|S_v|}{|S|}$ Ch9. 神经网络 感知机 反向传播（BP）算法 Ch.10 遗传算法 根据所有属性即可能的取值，确定“染色体”的表示（即一个0/1/#串，每位分别代表某个属性值的某个取值，#表示 no care） 确定适应度函数！即描述某一“染色体”（即 某一特定解）的好坏程度，适应度大小会影响一条“染色体”被选中交换+保留的概率 一开始随机选择？若干条“染色体”，然后通过适应度函数 以及选择方法，选出其中的若干条 （选择方法 影响到exploration \u0026amp; exploitation trade） 两两进行交换，交换策略有多种；以及较低概率突变 加入这些新的“染色体”，并替换掉一些较差“染色体” Ch.11 强化学习 Bellman等式 （策略评估） 其中 $\\delta(s,\\pi(s),s’)$表示从状态s 且采用了action $\\pi(s)$，会转移到状态s‘ 的概率 时间差分（TD）算法 （用来学习/更新值函数 以及 策略）\n其中$r_t$为一次经验，$R^{(0)}=r_t+\\gamma V(s_{t+1})$ N步TD：即$R^{N}=r_t+\\gamma r_{t+1}+\\gamma^2r_{t+2}+…+\\gamma^nV(s_{t+n})$替换$R^{(0)}$ 划重点 搜索（对于给定的搜索问题了解深度、广度以及启发式搜索的求解方案，启发式搜索中了解启发式函数的定义以及会展开搜索树）； 推理和知识表示（掌握命题演算、谓词演算以及如何进行推理，可参考课后习题） 不确定性推理（重点掌握贝叶斯网络以及马尔科夫网络，知道网络的构建以及联合概率分布如何约简以及怎么进行因果推理和诊断推理） 符号学习（掌握决策树构建，给出数据案例可构建ID3或C4.5的树） 神经网络（掌握感知机学习算法、BP算法，给出数据案例可通过算法得到相应的网络结构） 遗传算法（掌握对给定问题可通过遗传算法解决，怎么编码，怎么进行交叉、变异等操作，最终得到解） 强化学习（掌握Bellman等式以及状态值函数的计算，TD算法） 博弈（掌握博弈矩阵定义方法，掌握帕利托优解和纳什均衡解定义，可找出不同问题的解，可参考课上例子） ","date":1663579997,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1663579997,"objectID":"8c12c2a7e0e1bb49364d1d0b02873448","permalink":"https://hzyzh.github.io/post/notes-ai/","publishdate":"2022-09-19T09:33:17Z","relpermalink":"/post/notes-ai/","section":"post","summary":"Ch2. 搜索 OPEN, CLOSED列表：OPEN记录待搜索结点；CLOSED记录已搜索结点\n最佳优先搜索 定义一个启发式算法：按照一定启发式函数 对每个OPEN结点排序；按顺序在OPEN中搜索\nA* 算法 每个节点的优先级：$f(n)=g(n)+h(n)$\n$f(n)$，n的综合优先级；$g(n)$，n距离起点的代价（bfs）；$h(n)$，n距离终点的预计代价，启发函数！ 若$h(n)$始终=0，则退化为了Dijkstra算法； 若$h(n)$始终\u003c=节点n到终点的代价，则A*算法保证能找到最优路径！ Ch4. 知识表示 常见知识表示方法：\n一阶谓词表示 产生式表示 语义网络表示 框架表示 脚本表示 一阶谓词表示 产生式表示 例子：若ppp 则qqq\n​\tP$\\to$Q 或 IF P THEN Q （产生式）","tags":["Lecture notes","CS","Artificial Intelligence"],"title":"artificial_intelligence","type":"post"},{"authors":null,"categories":["Lecture notes"],"content":"Ch1. Introduction data mining 从大数据库中挖掘有用的信息，然后用它来做重要决策\n初始数据可能无法直接使用，需要先：collect，clean，transform into a standardized format\ndata mining的四个super-problems： association pattern mining，clustering，classification，outlier detection\nclassification：分类任务 有标签（class label） classification 和 regression（回归：标签是一个值） 都是supervised learning task supervision：指特殊列（data matrix中，即标签）被用来direct the data mining process classification methods： 支持向量机（support vector machines） K-nearest neighbor classification（KNN）K-近邻算法： 就是先（随机？）取若干个点，将离他们最近的k个样本点分别划入对应的区域 决策树（decision trees） rule-based classifier：不知道 可以视为有监督版本的clustering！ clustering 将数据集分为多个子集，每个子集在属性值相关，各个子集比较相似 $\\textcolor{red}{当一行的某一属性与其他行的该属性显著不同时}$，$\\textcolor{red}{它被视为一个anomaly，问题也变为了outlier; analysis}$。 anomaly detection（outlier detection / novelty detection） association pattern mining 最初版本：data matrix的值只取0或1（可以推广至数值/枚举型属性值） frequent pattern mining problem： Ch2. Data Preparation data preparation phase：\nfeatrue extraction and protability(数据类型转换) data cleaning(清除错误数据，inconsistent不一致的数据（即在不同地方不完全匹配），还有缺失的数据可能被重新估计出来？) data reduction, selection, transformation multidimensional data vs complex data\nID：one distribution， each point is independent on others？（mul）each point is generated from the same （unknown） distribution！ 四种基本的数据模式\nnominal（名义的） data：如城市、物种 ordinal（顺序的） data：如速度快慢（快、中、慢）（非连续的，有限的？） interval data：有大小关系，且是数值，没有最小！ ratio data：interval data，有最小！（绝对0） data portability\n一种数据类型 可转换成其他数据类型 的能力（保持性质） Haar Wavelet Transform？？\n将一个time series（非id的？） 不断二分并获得coefficient，得到id的数据？ MDS（graphs$\\to$ numeric multidimensional）\n不会 Similarity graph（any type$\\to$ graphs）\nCh3. Similarity distance vs similarity 数据散点图上的距离，不能简单的代表两个数据的similarity！（因为distribution，我们只关心有数据的范围；还有varied local density） Mahalanobis distance：stretch a dimension（/direction？） follow the data path！找到从A到B最近的一条path，来表示两者的similarity Text Similarity Measure Dynamic Time Warping Distance（DTW） 两个series建立 一对一的 同length 映射（将一些点延长？）分成若干个segment，每个segment匹配，时间作为contextual attribute，具体值不关键，主要关心order！ kernel choice： kernel function：\n将数据点 从一个特征平面 mapping 到另一个特征平面！ 例如D是数据集，则一个kernel function k可能：$D\\times D\\to R$ 为了take data distribution into consideration！\nMultiple Kernel Learning – reduce the risk of choosing an unsuitable kernel by using multiple kernels (learn weights)\nDistance metric learning – adapt similarity measurements to the task automatically from data (space transformation)\nProduce data dependent kernel directly from data\n$\\star$ Isolation Kernel：\n先从样本中随机取t个样本点，用它们将数据分布划分为t个区域（完全依赖于数据分布，与其他信息无关！）（用isolation forest的方法），重复多次，获得对原数据分布的多个划分？然后计算两个点的距离就是看它们在多少个划分里被划分进了同一区域 Ch4. Data Mining Algorithm 就是模型的训练过程\ntransaction：表示data？；itemsets：output？ classification problem\n决策树算法 节点 属性值的选取标准： information gain：difference between the amount of information needed to determine the class？ Set-covering算法： 基于rule-base classification 每次学习一个rule，并将该rule覆盖的样本剔除，对剩下的样本继续以上操作 K-Nearest算法：直接基于原始训练数据建立模型！ Support Vector Machines（SVM） clustering problem\nk-means clustering DBSCAN：首先获得数据样本分布，然后有一个threshold，高于它的连接的样本点为一个cluster Spectral clustering： 1.any data type $\\to$ similarity graph; 2.similarity graph $\\to$ graph embedding in multidimensional data? outlier problem\nkth-nearest neighbor：\n每个点找k个最近的数据点，根据这k个点决定是否为outlier！ isolation forest：\n构建一个二叉树（孤立森林）：最终将每个样本点都独立出来 如何做？随机选取一个超平面（将样本点二分！） outlier总是很容易区分，对应较短的path！ 重复多次以上步骤，统计每个样本点的average path length：短的更可能是outlier！ 需要subsampling：（即先对总样本随机取子集）缓解swamping effect和masking effect masking effect：一个outlier未被检测出来（因为旁边的其他outlier点） swamping effect：一个正常的数据点被认为是outlier（因为旁边的其他正常数据子集） IDK：估算任意两点/点和整个数据集D 之间的similarity（来进行anomaly detection）\nkernel mean embedding：就是给定一个定义于$\\Omega$，数据分布P，kernel function k（$\\Omega\\times \\Omega$），一个随机变量X的kernel mean embedding就是它在该数据分布上，k的平均值！ 关键是：转换成了distributional kernel！$\\hat{K}(P_S,P_T)\\approx\u0026lt;\\hat{\\phi}(P_S),\\hat{\\phi}(P_T)\u0026gt;$，其中S,T为数据集，P表示该数据集的分布distribution！\nfrequent pattern mining\nenumeration tree apriori algorithm Ch5. Spatial data mining spatial data：非id的！（但是可以通过一些方法（ch2）转换为id的）\nspatialtemporal data：包含temporal component（时间的？） contextual / behavioral attribute：contextual 提供背景/参考的属性，例如：测量海平面气温（这是behavioral attribute）时，地理位置、时间 都可以是contextual attribute！\nspatial data基本上都是作为contextual attribute的！轨迹图trajectory例外（只有时间时contextual） shape $\\to$ time series：通过顺时针/逆时针扫描一遍，大小为中心距离\n避免shape rotation（同一图形不同旋转得到不同time series）： DTW：similarity measure for 序列数据/trajectore\nDTW与behavioral attribute的属性无关\nCh6. Graph Mining Graph Edit Distance: $Edit(G1,G2)$=通过一系列操作（+点，-点，label替换，+边，-边），将G1转换为G2的最少步数\n1. Frequent Substructure-Based Transformation and Distance Computation\n2. Topological Descriptors\n3. Kernel-Based Transformations and Computation\n（m to the power of n：m的n次方）\nkernel Random Walk kernel： 只需在product graph上walk即可，因为这就是所有可能的相似路径了！ k-medoids： WL-kernel， IGK-kernel\nCh7. Mining Discrete Sequences bag-of-words(BOG) model：首先分解为frequent pattern，统计各pattern的出现次数，顺序无关（视为一个大集合）\nHMM： hidden markov model： 隐藏状态$S\\in{1,…,I}$；观测值$O\\in{y_1,…,y_K}$； 隐藏状态$S_t$仅依赖于前一个隐藏状态$S_{t-1}$，观测值$O_t$仅依赖于当前隐藏状态$S_t$ hidden markov …","date":1645547597,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645547597,"objectID":"55e1755ba59e34bf224dafe94b952ac8","permalink":"https://hzyzh.github.io/post/notes-datamining/","publishdate":"2022-02-22T16:33:17Z","relpermalink":"/post/notes-datamining/","section":"post","summary":"Ch1. Introduction data mining 从大数据库中挖掘有用的信息，然后用它来做重要决策\n初始数据可能无法直接使用，需要先：collect，clean，transform into a standardized format\ndata mining的四个super-problems： association pattern mining，clustering，classification，outlier detection\nclassification：分类任务 有标签（class label） classification 和 regression（回归：标签是一个值） 都是supervised learning task supervision：指特殊列（data matrix中，即标签）被用来direct the data mining process classification methods： 支持向量机（support vector machines） K-nearest neighbor classification（KNN）K-近邻算法： 就是先（随机？）取若干个点，将离他们最近的k个样本点分别划入对应的区域 决策树（decision trees） rule-based classifier：不知道 可以视为有监督版本的clustering！ clustering 将数据集分为多个子集，每个子集在属性值相关，各个子集比较相似 $\\textcolor{red}{当一行的某一属性与其他行的该属性显著不同时}$，$\\textcolor{red}{它被视为一个anomaly，问题也变为了outlier; analysis}$。 anomaly detection（outlier detection / novelty detection） association pattern mining 最初版本：data matrix的值只取0或1（可以推广至数值/枚举型属性值） frequent pattern mining problem： Ch2.","tags":["Lecture notes","CS","Data Mining","Machine Learning"],"title":"data_mining","type":"post"},{"authors":null,"categories":["Lecture notes"],"content":"计算机图形技术范式的演化 字符显示\n文字加数字的伪图形；命令行；文本格式编码；单任务\n矢量显示\n笔画文字和线画图形；命令行；存储和操纵复杂（笔画）；单/多人物\n二位光栅扫描显示（Bitmap Raster）\n窗口、图标、清洗文字即图案；直接选取对象；桌面；多任务\n图形工作站及多视角投影（3DTV）\n实时 三维 实物虚化 虚物实化；多维输入设备\n一些工业标准（ad hoc Standard）\nOpen GL； DirectX； X-Window； Postscript（标准图形支撑软件）\n计算机图形系统\n数据平台 四种几何模型：线框模型（线）、曲面模型（面）、实体模型（体）、点云模型（点） 主要差异在于几何基元 支撑平台 重要图形标准：图形核心系统GKS，PHIGS，事业、工业标准 ","date":1645181515,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645181515,"objectID":"311de8db2a23b3ffa2712e9ce9b23b23","permalink":"https://hzyzh.github.io/post/notes-graphics/","publishdate":"2022-02-18T10:51:55Z","relpermalink":"/post/notes-graphics/","section":"post","summary":"计算机图形技术范式的演化 字符显示\n文字加数字的伪图形；命令行；文本格式编码；单任务\n矢量显示\n笔画文字和线画图形；命令行；存储和操纵复杂（笔画）；单/多人物\n二位光栅扫描显示（Bitmap Raster）\n窗口、图标、清洗文字即图案；直接选取对象；桌面；多任务\n图形工作站及多视角投影（3DTV）\n实时 三维 实物虚化 虚物实化；多维输入设备\n一些工业标准（ad hoc Standard）\nOpen GL； DirectX； X-Window； Postscript（标准图形支撑软件）\n计算机图形系统\n数据平台 四种几何模型：线框模型（线）、曲面模型（面）、实体模型（体）、点云模型（点） 主要差异在于几何基元 支撑平台 重要图形标准：图形核心系统GKS，PHIGS，事业、工业标准 ","tags":["Lecture notes","CS","Graphics"],"title":"graphics","type":"post"},{"authors":null,"categories":["Lecture notes"],"content":"Intro 软件工程：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程化应用与软件中（软件工程复杂性导致的）\n软件质量？何优何劣？\n可从“外部”何“内部”考察 外部：用户直接感觉到的 正确性：依据规约 完成任务 鲁棒性：异常情况 完整性：非法访问和修改 易扩展性：软件因规约改变而改变（需求改变，可以很容易的修改至满足需求） 易复用性：软件模块，可以复用到另外的软件中 兼容性：不同软件模块组合的难易程度 高效性：尽量少使用硬件资源、处理时间、内外存、带宽 $\\cdots$ 内部：用户不能直接发觉的（源码、设计报告、分析报告等） 应对复杂性的途径：\n“元方法”\n分解（Decomposition）：分而治之 抽象（Abstraction）：将需求（对象）抽象成类 层次化（Hierarchy） “结构化”开发方法\n自顶向下的功能设计、逐步求精、过程抽象、模块化技术\n瀑布型模型：软件生命周期模型\n需求分析（可行性）$\\to$specification$\\to$总体设计（伪代码）$\\to$细节设计$\\to$实现$\\to$验证确认$\\to$发布 问题 实际代码晚 需求变化的支持？ 无软件维护阶段 敏捷编程开发模型：面向对象程序开发常用的模型\n软件模块化 重要性质\n易分解性（Decomposability）\n复杂问题分解成子问题\n易组合性（Composability）\n软件单元自由组合成新的软件\n易理解性（Understandable）\n不牵涉太广；自描述（一个软件模块的含义只需依赖自己？）\n连续性（Continuity）\n规约中的小变化也只会引起结构的小变化\nDesign method: Specification $\\to$ Architecture\n模块保护（Protection）\n异常不扩散/扩散范围有限（异常处理）\nFive Rules（降低耦合度）\n直接映射\n模型（问题）和代码（软件）直接映射\n少接口\n模块之间尽量少通信\n小接口\n模块的接口要小\n显示接口\n显示指出：A向B传递？or B向A传递？\n反例：全局变量（不知道A和B之间的接口关系）\n信息隐藏\npublic、private啥\n模块\n根本特征：“相对独立，功能单一” 低耦合，高内聚 ​\t复用\n传统技术复用支持\n过程（Routine）\n包（Package）\n都是啥？\n面向对象开发方法\nvs 结构化方法\n结构化思想（基于功能的分解）：\n有局限性（如对于不同数据类型） 数据抽象 要素：操作（函数），客体（对象）\n发展\n一：无类型的二进制数据 到 基本数据类型 二：基本类型到用户自定义类型（Pascal） 三：到抽象数据类型——面向对象 契约式设计 一个软件模块，有precondition（权力），和postcondition（义务）\nprecondition：该软件模块正确执行需要满足的条件\npostcondition：执行完该软件模块后应该满足的条件\ninvariant：对整个类，它规定了该类任何实例调用任何方法都必须满足的条件\n无需条件判断了~\ncreator program：cp {post \u0026amp; inv} routine：{pre \u0026amp; inv} r {post \u0026amp; inv} 契约写入document（接口）\n与assert对比：\n用户可显式看到 pre，post，inv document 继承 。。。 防御式编程：\n需要自己进行验证输入是否符合条件，并给出报错 异常处理 （当契约失效时）\n程序中throw但未处理的异常，需要显式声明出来！\n但对于那些常见的 uncheckedError？（如空指针引用，数组越界啥的）不需要显式声明出来 对于可能的checkedError，Java程序必须：要么通过throw声明抛出，要么通过try-catch处理，否则不能通过编译！ Throwable：\nError（system error） Exception RuntimeException（unchecked error：如除零，数组越界，空指针解引用） unchecked error应在测试环节都解决掉 。。。（checked error：与外界交互时的错误，如类型错误，文件找不到。。。） 异常处理 和 DbC（当情况不对时处理 vs 定义何时能正确运行；二者互补）\nUnchecked：当契约失效时发生的异常 Checked：不时会发生的，必须要考虑进的情况（不算违背契约） 因此，使用DbC设计代码，代码会分为两部分： 与外界交互的部分，没有precondition！需要考虑各种情况，有各种exception handling！ 与外界隔离的代码部分，有强precondition！依赖1部分检查得到正确的交互输入从而往下执行！不会抛出异常！ 异常转换\n在面向对象程序设计中，对象类可能会调用各种 对象无关的 库函数，库函数可能抛出应用无关的异常，对此，对象类需要catch相应的应用无关异常，并抛出对应的应用相关异常（如果没有解决掉异常，需要再抛出异常！） Eiffel Exception 基本概念\nsuccess：程序终止在符合契约的状态；反之则失败 exception：会导致程序失败的runtime-event（如果没有recover，就会导致调用失败） 一个过程（程序）的失败，会导致它的调用者exception 合理的处理异常：仅2种方式\nFailure：结束调用，并汇报failure，返回给调用者Exception Retrying：再次尝试调用 异常机制\n一个过程（routine）可以包含rescue clause；rescue clause中可能包含retry 没有执行retry（或执行失败）的rescue clause，会导致routine failure； 如果一个routine内发生异常但没有相应的rescue clause，就会导致该routine fail，并返回调用者exception DbC：\n注意，retry语句，指返回到正常开始执行前！\n缺少rescue clause的routine，相当于有一个默认的rescue clause：$default_clause$，负责恢复INV！\n设计原则 面向对象设计原则\n可维护性：软件能被理解、改正、适应、扩展的难易程度 可复用性：重复利用 包括一堆原则 单一职责：一个类，应仅有一个引起它变化的原因\n会把不同的职责，分离到多个不同的类，并通过对象组合的方式，来将它们封装在一起 开放闭合原则：（$\\star$最重要）软件实体应该在尽量不修改原有代码的情况下进行扩展\n不改源码，改行为（抽象出父类，增加子类） 策略模式：当一个类中要用到其他类对象时，可以通过一个接口（其他类来实现该接口）来引用/创建该类实例，这样，当功能发生扩展，要用到的类发生改变时，不需要修改源码（通过读取配置文件方法） 模板方法模式：父类中定义模板类，并且确定好执行顺序，子类实现/重写模板类（just like my 高程project） 里氏替换：1.所有子类对象 必须是合法的父类对象；2.父类指针调用的任何成员函数，不需要知道它到底指向的是父类成员函数 还是子类成员函数，就可以正常使用！\nDIP依赖倒置：要针对接口编程，不是针对具体实现！具体实现细节 依赖于抽象\n尽量使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明、数据类型转换；使用抽象层 编程，具体类写在配置文件中 不该依赖于具体类（任何类都不应从具体类派生）；不过稳定具体类可以派生（如String）；不该覆盖父类中以实现的方法！ 接口隔离原则：客户端不依赖于它不需要的接口；接口太大时，拆分成多个小接口，客户端只需要知道它相关的接口（只提供定制服务，不提供大接口）\n如，一个抽象类中定义了一堆抽象接口，则具体子类必须实现全部的接口，即使客户端只需要其中一小部分。解决方法：拆分成多个抽象父类。。。\n例子： 要实现一个计时的门：（引入了适配器） 或者使用多继承方法：TimedDoor同时继承Timer Client 和Door类\n合成/聚合复用：优先对象组合，而非继承来复用\n聚合：拥有关系，整体与部分（指针或引用）；合成：直接包含了其他类对象 合成/聚合复用是 黑箱复用（运行时确定具体复用什么类），HAS-A；继承则是 静态复用，破坏封装性，违背设计原则。。IS-A 根据Coad原则判断是否要用继承复用 LoD迪米特法则：（模块之间的信息隐藏）每个软件单位对其他关系紧密的单位仅有最小的知识\n类之间 弱耦合 如，类的属性 都不应设为public，而应设为private并提供接口来改变 设计模式 模式的定义：模式描述了 环境中不断出现的问题+解决问题的核心 =\u0026gt; 重用已有的解决方案\n软件模式：在一定条件下的软件开发问题及其解法；包括：问题描述、前提条件、解法、效果 软件模式大三律：必须经过3个以上不同类型的系统的检验，一个解决方案才能成为模式 设计模式定义：在特定环境下，为解决某一通用软件设计问题 提供的一套定制的解决方案 包括：模式名称、问题、解决方案、效果 分类：创建型、结构型、行为型模式 目的：创建型（创建对象）、结构型（处理类或对象的组合）、行为型（描述类或对象如何交互和怎样分配职责） 基础知识：\nJava的反射机制：在程序运行时获取已知名称的类或已有对象的相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和实例类型的判断等 具体来说就是：Class类实例可以通过newInstance方法+传入的类名字符串，创建一个该类的新实例（需要强制类型转换） 配置文件：纯文本文件（如XML，properties文件） 创建型模式：\n简单工厂模式（/静态工厂方法）： creator中的factory方法是静态方法，接收参数，根据参数类型，返回不同具体子类（这些具体子类具有共同的抽象父类）；\n客户端方法（调用静态工厂方法）中，配合配置文件，即可不改代码实现创建对象\n将对象的创建和使用分离：类A和B之间关系，不能同时有A创建B和A使用B（单一职责原则）\n简单工厂模式的简化：可以把工厂类 和 抽象父类合并（多提供一个静态工厂方法）\n模式缺点：1.不符合开闭原则（新增具体子类，需要修改静态工厂方法）；2.增加了类，增高复杂度\n工厂方法模式（虚拟构造器/工厂模式）：将实例化具体类对象过程 延迟到了工厂类的子类（具体工厂）！（这样就符合了开闭）\n不再是静态方法！！是通过在客户端程序中 用配置文件+反射机制 来实现的！\n工厂方法的重载：抽象父类中，可以定义多个重载的 创建具体子类对象 方法\n抽象工厂模式（Kit）：目的是 创建一系列相关的产品（一族产品）；工厂方法则是一次只产生一种产品\n例子： 和工厂模式差不多，就是有多个不同的（非重载的）生产方法\n增加新的产品族：很方便，符合开闭原则；但若增加新的产品等级结构（新生产方法），则需要改源码！\n每个具体的工厂，一般只有一个（单例）\n建造者模式：创建复杂的对象（由多个部件 按顺序 组合而成），将一个复杂的对象的 构建过程 和它的表示 相分离（可以复用）\n抽象Builder父类：有一个protected的product成员，以及若干构建组件的 抽象方法；\n具体Builder子类：实现各个构建组件的方法，直接作用在product上\nDirector类：有一个Builder指针，指向想要创建的对象类型对应的具体Builder；construct方法会按照一定顺序调用Builder的各组件构建方法（按什么顺序，通过修改Director类的construct代码）\n拓展：Director和抽象Builder合并：抽象Builder中提供一个静态接口Construct（接收一个具体Builder引用）；或者作为非静态接口，具体Builder实例直接调用Construct接口\n钩子方法： 然后在Construct中判断，在具体Builder中重写钩子方法。可是为什么不直接在具体Builder中，把不需要的接口实现为空 …","date":1645108107,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645108107,"objectID":"801de4c505d891fb671fdb4888992efc","permalink":"https://hzyzh.github.io/post/notes-ood/","publishdate":"2022-02-17T14:28:27Z","relpermalink":"/post/notes-ood/","section":"post","summary":"Intro 软件工程：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程化应用与软件中（软件工程复杂性导致的）\n软件质量？何优何劣？\n可从“外部”何“内部”考察 外部：用户直接感觉到的 正确性：依据规约 完成任务 鲁棒性：异常情况 完整性：非法访问和修改 易扩展性：软件因规约改变而改变（需求改变，可以很容易的修改至满足需求） 易复用性：软件模块，可以复用到另外的软件中 兼容性：不同软件模块组合的难易程度 高效性：尽量少使用硬件资源、处理时间、内外存、带宽 $\\cdots$ 内部：用户不能直接发觉的（源码、设计报告、分析报告等） 应对复杂性的途径：\n“元方法”\n分解（Decomposition）：分而治之 抽象（Abstraction）：将需求（对象）抽象成类 层次化（Hierarchy） “结构化”开发方法\n自顶向下的功能设计、逐步求精、过程抽象、模块化技术\n瀑布型模型：软件生命周期模型\n需求分析（可行性）$\\to$specification$\\to$总体设计（伪代码）$\\to$细节设计$\\to$实现$\\to$验证确认$\\to$发布 问题 实际代码晚 需求变化的支持？ 无软件维护阶段 敏捷编程开发模型：面向对象程序开发常用的模型\n软件模块化 重要性质","tags":["Lecture notes","CS","Object-Oriented Programming"],"title":"Object Oriented Design","type":"post"},{"authors":null,"categories":["Lecture notes"],"content":"Intro 目标\n多媒体技术在计算机上的表示（怎样表示一个视频、声音、图形）\n掌握多媒体编码标准\n当前的多媒体处理技术和相关算法\n什么是媒体\n媒体（Media）：发布信息，表现信息的手段、方法、工具、设备或装置 两种形式： 感觉媒体：人——人 或 人——机交换信息的形式（可以通过视觉、听觉 感知到） 表示媒体：计算机内部或机——机交换信息的形式（二进制编码形式存储）：称为数字媒体形式 感觉媒体和表示媒体的转换（输入设备、输出设备），是主要研究部分！ 按生成属性分类 自然媒体：客观世界存在的。。。经过特定设备，进行数字化和编码处理后得到的 数字媒体 （如：Digital video，Bitmap image） 合成媒体：以计算机为工具、采用特定符号、语言、算法表示等，由计算机生成（合成）的文本、音乐、动画等等 （如MIDI？graphics，computer animation） 两者区别： 1.客观世界存在否； 2.表示方式： 自然媒体：离散样本方式； 合成媒体：由符号、语言、算法 所表示的 啥是多媒体？ any combination of text, graphic art, sound, animation, video delivered by computers 多媒体技术：可以大大提高人机交互效率（各种人机交互接口） 多媒体技术的研究内容\n各种媒体输入 $\\to$ 媒体的表示（编码） $\\to$ 媒体的编辑（对媒体信息的一些修改？） $\\to$ 媒体的集成（多种媒体的同步、集成等等） $\\to$ 媒体传输（一般是网络） $\\to$ 媒体消费（*要把表示媒体 转换为 感觉媒体！） 媒体的输入 自然媒体：通过捕获 \u0026amp; 数字化（自然界中真实存在） 将物理量、化学量、生物量等转换成电信号（如麦克风把声波 从 机械信号 转换成 电信号） 然后通过采样、量化、编码等处理，将模拟电信号 转成 特定格式的数据文件 合成媒体：通过建模（通过专门的算法、语言、脚本来描述） 创建：先建模，得到 采用特定符号（语言）或某种算法表示的媒体（如编码文本、MIDI音乐、计算机动画、Graphics。。。） 渲染：最后展示的时候，要转换为 感觉媒体（离散的样本点） 渲染 就是将合成媒体，转换为离散样本 媒体的表示 文本编码 声音编码 图像编码 多分辨：一个图像可以支持多分辨率，即根据当前场景的复杂程度，选择不同分辨率 视频编码 （以上三个都：）压缩问题 和 传输问题 可伸缩性：一套码流 支持多种分辨率（标清：只解析标清码流；高清：同时也解析高清码流。。。） 编码标准： 音频：MPEG 图像：bmp，gif，JPEG 视频：H系列（要求编码解码实时性），MPEG系列（不要求编码，但要求解码实时性） 媒体的编辑（editing） 内容增删改；变换、效果处理；布局安排；类型转换（自然形式（媒体）的取样表示 $\\to$ 符号化 $\\to$ 符号表示） 媒体的传输 网络传输 载体发布：CD、DVD、HD DVD、蓝光Disk 媒体的消费 文本：浏览、阅读 图像：渲染 等等 多媒体技术的发展\n网络化 文本编码 ASCII码：7位二进制编码；96个可打印字符+32个控制字符\n一般ASCII码为：ISO-646-US标准；也有其他本地化版本（ISO-646-） 扩充ASCII码（ISO-8859）：8位二进制编码（低位兼容ASCII（0+7位）；高位从0xA1开始定义，分为若干不同的字符集）\n汉字编码：GB2312-1980：（简体中文字符集，+ASCII码等西文字符）\n区位码（8bit）+基类码（8bit）（94个区+94个位） 存储时，为了和ASCII码区分，将区位码 和 基类码都加上A0（单字节的最高位置为1） GB12345-1990：\n繁体汉字编码（专门用来编码繁体的） CJK（中日韩）\nGBK（GB2312 + CJK + …）\n双字节编码，第一字节最高位必为1，第2字节最高位不一定！（仍能和单字节的ASCII码兼容） 与GB2312-80向下兼容 UCS：将所有字符统一在一个字符集中（留了00 0000 0000 到10 ffff ffff的编码空间）\nUCS的变形显示形式之一UTF-8（可变长形式编码）\nUTF-16：两个字节一起来读入（允许插入一些4字节的UCS-4字符）：\n读入两个字节：如果在D800到DFFF之间，则表示是四个字节的字符，否则两个字节 UTF-16能表示UCS中的全部字符 数字图像基础 颜色模型\n颜色三要素： 色调：颜色的外观，决定于光的波长 饱和度：纯度/彩度（彩色中含白光的量） 亮度：强度，能量 颜色模型： 加色模型RGB；减色模型CMY(K黑) 抖动： 用空间换效果 八叉树颜色量化算法！ 图像与图形\n图像（Image） 取样图（点位图）：图像的空间离散化 图形（graphics） 矢量图：通过计算机指令表示 数字取样图像的表示\n分辨率（屏幕、图像 分辨率） 像素深度（存储每个像素所用的位数） 调色板（颜色查找表，只需存储索引） 常用图像文件的格式\nbmp：windows通用的图像文件格式 包含：文件头，信息头，调色板，位图数据 位图数据：扫描行是由底向上存储的，这就是说，阵列中的第一个字节表示位图左下角的像素，而最后一个字节表示位图右上角的像素。 一行的字节数必须为4的倍数。 gif：颜色少（不超过256），特别小；图像中可加入文本 png 合成图像（与数字取样图像相对）的创建与表示\n合成图像：使用算法或几何要素以及材料性质，来描述形体；显示时，会根据观察者位置以及光线来生成景物\n建模方法：\n几何造型技术：线框模型、表面模型、实体模型\n线框模型：点和棱边，没有面，不能表示含曲面物体\n表面模型：面的集合表示物体，环界定面的边界；但不能计算体积、表面积等\nBezier样条曲线函数：有$p_0, p_1,\\cdots, p_n$n+1个点，以此模拟出一条曲线：（除$p_0,p_n$外，其他点都仅提供方向信息，一般不经过）\n实体模型\n过程造型\n分形几何：初始图形的每一点，不断重复使用给定的变换函数（固定的或随机的） 如：三角形（初始元）+每边突出一个角（生成元generator） 统计自相似分形几何构造：重在随机性（如模拟叶脉） L系统 粒子系统 基于物理的建模 数字图像的展现\n展现：将取样/合成图像从内部表示转换为在图像输出设备上可见的视图\n​\t包括：reconstruction：取样图像 展现到输出设备；rendering：合成图像 展现到输出设备（比较复杂，计算量很大）\nCRT显示器：阴极射线（控制信号 控制电压大小），同时只有一束电流！（不断一行一行发射）\n液晶显示器：通过改变光的振动方向，来控制显示强度（有一个配光板，只有某一方向震动的光能通过）\n显示控制卡（or图形卡、视频卡、图形加速卡、视频适配卡，显卡）\n包括：显示存储器（VRAM），GPU，绘图与显示控制电路 VRAM：存储正在显示的图像数据（双缓存：还存储下一帧要显示的内容）；以及作为GPU的内存！ GPU：以及将RGB数字信号转换为模拟信号 绘图与显示控制电路：对CRT或液晶显示器进行控制，与CPU一起完成图像生成与更新。 GPU（graphic processing unit）：\n主要为了大量的、并行的数据计算：渲染！（rgb$\\to$模拟信号） NVIDIA的GPU：CUDA核心（通用GPU核心！可以像在CPU上编程一样在GPU上编程，也可以图像渲染）；Tensor核心：专为张量和矩阵计算（深度学习） 图像绘制过程：\n光线跟踪方法（ray tracing） 正向效果：光源处发出无数光线，在到达表面上反射、折射，直到部分光到达投影平面（/反射、折射一定次数） 逆向效果：以像素为起点 添加阴影（通过光源+建模和算法计算得到）、表面细节、纹理、材质 方式：点绘制、面绘制、体绘制 rendering pipeline：（OpenGL） 需要定义：光源，观察点（视点），成像面，距离，大小。。。 景物的模型$\\to$取景变换（坐标变换）$\\to$视域裁剪（快速判断哪些物体在视域内）$\\to$三角化（把所有景物转化为三角网格mesh）$\\to$光栅化$\\star$（关键步骤，所有可视对象转化为像素！一般通过光线追踪实现）$\\to$隐藏面消除（保留最靠前的对象像素，还要考虑透明效果、折射反射效果）$\\to$明暗处理$\\to$阴影生成$\\to$纹理映射$\\to$最终景物的像 （此即rendering pipeline全过程） 纹理：用一些算法，将真是的照片蒙在mesh上，不影响几何形状；几何纹理：对几何形状也会产生一定扰动（如一个高尔夫球） 合成图像的展现\n数字视频 模拟视频：随时间变化其内容的一组图像（n帧/秒），又叫运动图像\n彩色电视图像摄取、传输和重现的过程：拍摄和播放都采用 光栅扫描 方法（依次扫描成像平面每一像素） 彩电信号传输：用Y（亮度）、C1、C2（色差信号，与彩电制式相关，比如我国用PAL制式、美国用NTSC制式） 显示：光栅扫描（逐行扫描；也有 隔行扫描interlaced（奇数场+偶数场$\\to$1帧图像），隔行扫描 转化到逐行扫描 可能会造成模糊） 视频信号： 空间特性：需要有时间回扫（行回扫、列回扫）；一般宽高比为4：3或16：9 时间特性：动作连贯要求 帧频\u0026gt;15f/s；无闪烁要求\u0026gt;50f/s PAL：每秒50场（隔行扫描）；NTSC：每秒60场。计算最（亮度信号）高频率时：全屏光点总数$\\times$每秒帧数（场数除以二）/2（因为两个像素构成一个周期） 载波频率：PAL：8MHz；NTSC：6MHz 电视信号的彩色空间：Y（亮度信号）,C1,C2（色差信号），根据RGB转换 为啥要用？：因为彩色电视信号 与 黑白电视兼容；利于压缩信号带宽 视频信号种类： 复合电视信号：将 亮度、色度信号 以及同步信号 复合成单一信号。适合远距离传输（只需要单信道） 接口种类：梯形的 HDMI高清信号；宽体型（15根信道）VGA 数字视频：易于编辑、修改、存储、传输，图像质量更好\n视频信号数字化：模拟视频信号输入：Y、U、V（模拟视频信号是连续的，时间和幅值上都是）\n1.滤波（过滤掉噪声）；2.取样（时间轴上（和x轴y轴？）离散），亮度信号采样频率13.5MHz；3.量化（值还是连续的，用8-10bit表示一个信号）；4.PCM编码（1.协议：如何解释这些比特流；2.压缩：数据量过大）=\u0026gt;数字Y、U、V信号\n取样：Y分量：标清水平分辨率720（一行 有720个像素可见）；垂直分辨率：PAL：576行可见；NTSC：480行可见（因为JPEG编码，需要按16×16的块）\nU、V/I、Q：人眼对其不如Y信号敏感，因此不用每个采样点都有\n数字视频的计时：00;02;51;20（小时；分钟；秒；帧）\n失落帧编码：00;02;51;20（分号），用于处理NTSC的实际频率为29.97fps：每一分钟的00秒，没有00和01帧；每十分钟的00秒，有00和01帧（类似闰年） 非失落帧编码：00:02:51:20（冒号） 计算机合成视频\n计算机动画：采用计算机合成，可供实时演播的一系列画面 的技术（是合成数字视频） 运动控制 类别：刚体运动：一些关键部件组成，不变形，仅相互位置关系变化；变形体运动：不仅相互位置变化，而且也变形 运动控制的方法： 关键帧人工给出几个关键帧的位置、形状、方向等等；中间帧靠计算机自动合成 计算法：（抽象成物理、数学模型）动力学（受力、加速度。。。）、随机方法（火焰、云彩、瀑布等，需要添加一些随机方法）、行为规则 运动捕获：现实的运动图像捕获（记录许多样本点的运动）（如人脸的表情） 重用以前的动作 声音 声音的数字化 声音：\n物理特性：频率（音调，音高）；强度/振幅（音量）；波形（音色） 次声：0-20Hz；可听声：20-20kHz；超声：20kHz- 可听声中，分 语音（300-3400Hz） 和 全频带声 …","date":1645094449,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1645094449,"objectID":"9e7ae1c08d0faeb04765a24ea7d1b34a","permalink":"https://hzyzh.github.io/post/notes-multimedia/","publishdate":"2022-02-17T10:40:49Z","relpermalink":"/post/notes-multimedia/","section":"post","summary":"Intro 目标\n多媒体技术在计算机上的表示（怎样表示一个视频、声音、图形）\n掌握多媒体编码标准\n当前的多媒体处理技术和相关算法\n什么是媒体\n媒体（Media）：发布信息，表现信息的手段、方法、工具、设备或装置 两种形式： 感觉媒体：人——人 或 人——机交换信息的形式（可以通过视觉、听觉 感知到） 表示媒体：计算机内部或机——机交换信息的形式（二进制编码形式存储）：称为数字媒体形式 感觉媒体和表示媒体的转换（输入设备、输出设备），是主要研究部分！ 按生成属性分类 自然媒体：客观世界存在的。。。经过特定设备，进行数字化和编码处理后得到的 数字媒体 （如：Digital video，Bitmap image） 合成媒体：以计算机为工具、采用特定符号、语言、算法表示等，由计算机生成（合成）的文本、音乐、动画等等 （如MIDI？graphics，computer animation） 两者区别： 1.客观世界存在否； 2.表示方式： 自然媒体：离散样本方式； 合成媒体：由符号、语言、算法 所表示的 啥是多媒体？ any combination of text, graphic art, sound, animation, video delivered by computers 多媒体技术：可以大大提高人机交互效率（各种人机交互接口） 多媒体技术的研究内容","tags":["Lecture notes","CS","Multimedia"],"title":"multimedia","type":"post"},{"authors":null,"categories":["Lecture notes"],"content":"编译原理 introduction Lexical Analysis 一、词法分析器的作用 基本作用 读入字符流（用户的输入），组成词素（lexeme），输出词法单元序列 过滤空白、换行、制表符、注释等 将词素添加到符号表中 语法分析器通过调用 getNextToken api与词法分析器交互（获得下一个词法单元） why独立词法分析器？ 简化编译器 模块化设计（增强编译器可移植性） 词法单元、模式、词素 词法单元（Token）： \u0026lt;词法单元名（类型）、属性值（可选）\u0026gt; 如：\u0026lt;Id：abc\u0026gt;、\u0026lt;Number：123\u0026gt;、\u0026lt;Literal：“xxxx”\u0026gt; 语法分析器通过词法单元名确定词法单元序列结构 属性：一个模式匹配多个词素时，必须通过属性传递附加的信息 用于语义分析、代码生成等阶段 属性值通常是结构化数据（多信息）（因为不同目的需要不同属性） 模式（Pattern）： 描述了一类词法单元的词素可能具有的形式 类似于一个类 词素（Lexeme）： 源程序中的字符序列，和某个词法单元的模式匹配（词法单元的实例） 类的实例 二、词法单元的规约（正则表达式） 描述词法单元的方式：（有多种）正则表达式非常棒！\n串和语言 字母表（Alphabet）：有穷的符号集合 如：{0，1}，ASCII，Unicode（即包括各种文字） 串（String）：字母表中符号的有穷序列 串s的长度|s| 空串 $\\epsilon$ 一些术语（以banana为例） 前缀：ban、banana、$\\epsilon$ 后缀：nana、banana、$\\epsilon$ 真前缀、真后缀（除掉banana和$\\epsilon$） 串的运算 连接：x和y连接：xy 指数运算（幂运算）：$s^0=\\epsilon, s^k=ss^{k-1}$(连接) 语言的运算（L,M都是语言，见下） 并：$L\\cup M$ 连接：$LM={st|s\\in L,t\\in M}$ $L$的Kleene闭包：$L^*=\\cup^{\\inf}_{i=0}L^i$ $L^0={\\epsilon}$ $L$的正闭包：$L^+=\\cup^{\\inf}_{i=1}L^i$ 语言（Language）：某个给定字母表上的串的可数集合 正则表达式 字母表$\\Sigma$上的正则表达式的定义： 基本部分 $\\epsilon$是一个正则表达式，$L(\\epsilon)={\\epsilon}$ L(r)=正则表达式r所表达的语言 若$\\Sigma$上的符号a也是正则表达式，L(a)={a} 归纳步骤 选择：$(r)|(s): L((r)|(s))=L(r)\\cup L(s)$ 连接：$(r)(s):L((r)(s))=L(r)L(s)$ 闭包：$(r)^:L((r)^)=(L(r))^*$ 括号：无影响 优先级：（）\u0026gt; * \u0026gt; 连接 \u0026gt; | 正则语言：可以用一个正则表达式定义的语言 给正则表达式命名 正则表达式的扩展 基本运算符：前三种（+括号） 扩展运算符： 一个或多个实例：单目后缀$^+:r^+=rr^*$ 零个或一个实例：？ 字符类 $[a_1a_2\\cdots a_n]=a_1|a_2|\\cdots|a_n$ $[a-e]=a|b|c|d|e$ 不会使描述能力增强 正则表达式与词法单元的识别 词法分析器要求： 检查输入的字符串，在其前缀中找出和某模式匹配的词素 首先 正则定义 描述各种词法单元模式 定义$ws\\to(\\text{blank|tab|newline})^+$ 词法分析器识别出此模式时，不返回词素，直接过滤掉了~ 二义性：如 id 和 if 等关键字的词法单元模式 需要特殊处理（见下） 三、词法单元的识别（状态转换图） 状态转换图 状态转换图 点（状态State）： 表示已读入的符号状态 某些状态为 接收状态 和 最终状态，表明已找到词素 加上的接收状态表示最后读入的符号不在词素中 开始状态（初始状态）：Start边表示 边（转换Transition）：从一个状态指向另一个 边的标号是一个或多个符号 当前状态s，下一个输入符号为a，就沿s离开，标号为a的边到下一个状态 一般是人写正则表达式（比较友好），专门的算法去生成对应的状态转换图（人写不友好） 保留字和标识符的识别 保留字也可能符合标识符模式 解决方法： 在符号表中先填保留字，并知名它们不是标识符 为保留字建立独立的、高优先级的状态转换图 词法分析器的体系结构 从转换图 构造 词法分析器 的方法 变量State记录当前状态 一个switch根据State和输入字符转到相应的代码 每个状态一段代码，如果未找到对应的转换边（识别失败），则此法错误，需要处理错误！ 四、词法分析器生成工具及设计 词法分析工具Lex/Flex 通常和YACC/Bison一起使用，生成编译器的前端 Lex源程序的结构 声明部分 常量 正则定义 转换规则 模式{ 动作 } 模式：正则表达式 动作：表示识别到相应模式时采取的处理方式（C代码表示通常） 辅助函数 各动作中使用的函数 Lex中冲突解决方法 冲突：多个输入前缀与某个模式相匹配，或一个前缀与多个模式匹配 多个前缀可能匹配：选择最长的前缀 前缀和多个模式匹配：选择列在前面的模式 五、有穷自动机 本质和状态转换图相同，但只回答Yes/No\n两类：\n不确定的~（NFA)：一个符号可出现在离开同一状态的多条边上，$\\epsilon$可做标号（可能跳到多个状态？状态不唯一？） 确定的~(DFA)：对每个状态及符号，有且只有/最多只有一条边 两种自动机都识别正则语言\nNFA,DFA都可以识别正则表达式可描述的语言，反之亦然 识别：判定一个串是否属于对应正则语言 NFA,DFA的表达能力是等价的~ NFA（不确定）：\n有穷状态机和 S\n输入字母表$\\Sigma$\n转换函数对每个状态和$\\Sigma\\cup{\\epsilon}$中的符号，给出相应的后继状态集合\n$s_0$为开始状态\nS 的一个子集 F 被指定为接受状态集合\n输入字符串的接受：\nNFA接受输入字符串x：转换图中存在一条从开始状态到某个接受状态的路径（路径上的标号连接为x，忽略$\\epsilon$) NFA接受的语言：从开始状态到接受状态的所有可能路径的标号串的集合 容易从正则表达式转换\nNFA的不确定性使其不易实现：\n维护多状态 跟踪多路径 解决方案：DFA\nDFA（确定）：\n一个NFA被称为DFA，如果： 没有标号为$\\epsilon$的转换； 每个状态s和输入符号a，有且仅有一条标号为a的离开s的边 一个串能否被DFA接受：可高效判断 DFA的运行：代码很好实现！（因为同一时间状态唯一确定） NFA转换到DFA（子集构造法）：\n思想：构造得到的（目标）DFA的 每个$\\textcolor{red}{状态}$和NFA的 $\\textcolor{red}{状态子集}$对应（同时的多个状态） 在算法中”并行地模拟“NFA遇到一个给定输入串时可能执行的所有动作\n目标DFA状态之间的转换对应NFA妆台集合之间的转换\n理论上，最坏情况下DFA的状态个数会是NFA状态个数的指数个（幂级，$2^n$)\n​\t（一般而言，两者状态数量大致相同）\n算法：\n基本操作：\n$\\epsilon-$closure(s)（闭包）：从NFA状态s开始，只通过$\\epsilon$转换能到达的NFA状态集合 $\\epsilon-$closure(T)：T中所有状态s的$\\epsilon-$closure(s) move(T，a)：枚举T中所有状态，从T中某状态s出发，通过标号a（+$\\epsilon$转换）能到的所有NFA状态集合 算法1（计算$\\epsilon-$closure(T)）如下： 主算法：\n输出：Dstates：DFA状态，每个元素对应一个NFA状态集合\nDtran：DFA状态转换表 example Dtran：\nDFA状态数量的最小化 一个正则语言可对应于多个识别它的DFA（等价的）\n通过DFA的最小化可得到状态数量最少的DFA（不计同构，是唯一的）\n状态的区分 状态的可区分 如果状态s1和s2，存在串x，使得从s1、s2经x，一个到接受状态，一个到非接受状态，则x区分了s1和s2 若存在串区分了s和t，则s和t可区分，否则它们不可区分 不可区分的状态等价，可合并 =\u0026gt; 暴力算法，为所有两个状态对都试图找一个区分它们的串 DFA最小化算法： 所有可区分状态分开（迭代过程） base case：$\\epsilon$区分了接受和非接受状态 induction case：若s和t可区分，且s‘到s、t’到t有a边，则s‘和t’也可区分 最终没有区分开的状态就是等价的 从划分得到的等价类中选取代表，并重建DFA 构造：从$\\Pi_{\\text{final}}$中每个组选一个代表，作为最小化DFA中状态，构造过程很自然和显然 自动机到词法分析器 正则：识别单模式\n词法分析器：要识别多个模式！\n解决方法：NFA合并方法！\n引入新的$\\textcolor{red}{新的开始状态}$，并从该状态到各个原开始状态加$\\epsilon$转换边 得到的NFA所接受的语言是原来各NFA语言的并集 不同接受状态代表$\\textcolor{red}{不同的模式}$，所以不要合并到同一接受状态！ 确定化NFA可能引发冲突\n对得到的NFA（上面）进行确定化，得到DFA\n一个DFA的接受状态对应于NFA的状态子集，其中至少包括一个NFA的接受状态，$\\textcolor{red}{但是可能包括多个对应于不同模式的NFA接受状态！表示当前输入前缀对应于多个模式，存在冲突！！}$\n解决方案：优先级\n即当发生冲突时，哪个模式优先级更高\n词法分析器状态的最小化\n差别： 接受状态对应不同模式 对应不同模式的接受状态一定不等价 初始化分为：非接受状态、对应同一模式的接受状态、死状态$\\Phi$ 死状态$\\Phi$：当前状态没有对应输入字符的转换边，则进入死状态（即发生词法错误） 其余划分和构造相同 总结：\n词法规则 —（人完成）—\u0026gt; 正则表达式 —（机器自动完成）—\u0026gt; NFA —（程序算法完成） —\u0026gt; DFA —（如Lex/Flex，也自动完成）—\u0026gt; 词法分析器 Syntax（语法） Analysis 一、语法分析器 基本作用： 从词法分析器获得词法单元序列，能否由语言文法生成？ 报告语法错误信息 语法正确程序，生成语法分析树：通常是抽象语法树（AST） 程序设计语言构造的描述：常使用上下文无关文法（Context-Free grammar） 或 BNF 描述 二、上下文无关文法（CFG） 一个CFG包含四个部分：\n终结符号：组成串的基本符号（词法单元名字） 终结，即该符号不可继续展开（基本元素？） 非终结符号：表示串的集合的语法变量 非终结，即这个符号还可以继续展开 产生式：描述将终结符号和非终结符号组成串的方法 形式：头（左）$\\to$ 体（右）部 意义：即头部的非终结符号 可替换/展开成 右边的符号 头：非终结，体：非终结/终结 如：expression $\\to$ expression + term 元符号：| 是文法描述中的符号，而不是文法符号（如E $\\to$ E + T | E - T，表示可以多种展开方式） 开始符号： 一个文法描述的语言，就是所有符合文法的串的集合 文法的推导：\n将待处理串中某个非终结符号 替换为它的某个产生式的体（右部） 从开始符号出发，不断进行以上替换，得到文法的不同句型 若$A\\to\\gamma$，那么$\\alpha A\\beta=\u0026gt;\\alpha\\gamma\\beta$ 最左（右）推导：$\\alpha(\\beta)$中不包含非终结符号（每次推导都替换最左/右的非终结符？） 符号：$={\\text{lm}}^{*}\u0026gt;$，$={\\text{rm}}^{*}\u0026gt;$ =*\u0026gt;经零步或多步推导出 =+\u0026gt;经至少一步推导出 句型、句子、语言\n句型（Sentential form）=  …","date":1644964272,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644964272,"objectID":"03af0ba8f130fba529de33ecce4d890c","permalink":"https://hzyzh.github.io/post/notes-compiling/","publishdate":"2022-02-15T22:31:12Z","relpermalink":"/post/notes-compiling/","section":"post","summary":"编译原理 introduction Lexical Analysis 一、词法分析器的作用 基本作用 读入字符流（用户的输入），组成词素（lexeme），输出词法单元序列 过滤空白、换行、制表符、注释等 将词素添加到符号表中 语法分析器通过调用 getNextToken api与词法分析器交互（获得下一个词法单元） why独立词法分析器？ 简化编译器 模块化设计（增强编译器可移植性） 词法单元、模式、词素 词法单元（Token）： \u003c词法单元名（类型）、属性值（可选）\u003e 如：\u003cId：abc\u003e、\u003cNumber：123\u003e、\u003cLiteral：“xxxx”\u003e 语法分析器通过词法单元名确定词法单元序列结构 属性：一个模式匹配多个词素时，必须通过属性传递附加的信息 用于语义分析、代码生成等阶段 属性值通常是结构化数据（多信息）（因为不同目的需要不同属性） 模式（Pattern）： 描述了一类词法单元的词素可能具有的形式 类似于一个类 词素（Lexeme）： 源程序中的字符序列，和某个词法单元的模式匹配（词法单元的实例） 类的实例 二、词法单元的规约（正则表达式） 描述词法单元的方式：（有多种）正则表达式非常棒！","tags":["Lecture notes","CS","Compiler"],"title":"The Principles and Techniques of Compilers","type":"post"},{"authors":null,"categories":null,"content":"Wowchemy is designed to give technical content creators a seamless experience. You can focus on the content and Wowchemy handles the rest.\nHighlight your code snippets, take notes on math classes, and draw diagrams from textual representation.\nOn this page, you’ll find some examples of the types of technical content that can be rendered with Wowchemy.\nExamples Code Wowchemy supports a Markdown extension for highlighting code syntax. You can customize the styles under the syntax_highlighter option in your config/_default/params.yaml file.\n```python\rimport pandas as pd\rdata = pd.read_csv(\u0026#34;data.csv\u0026#34;)\rdata.head()\r```\rrenders as\nimport pandas as pd data = pd.read_csv(\u0026#34;data.csv\u0026#34;) data.head() Mindmaps Wowchemy supports a Markdown extension for mindmaps.\nSimply insert a Markdown markmap code block and optionally set the height of the mindmap as shown in the example below.\nA simple mindmap defined as a Markdown list:\n```markmap {height=\u0026#34;200px\u0026#34;}\r- Hugo Modules\r- wowchemy\r- wowchemy-plugins-netlify\r- wowchemy-plugins-netlify-cms\r- wowchemy-plugins-reveal\r```\rrenders as\n- Hugo Modules\r- wowchemy\r- wowchemy-plugins-netlify\r- wowchemy-plugins-netlify-cms\r- wowchemy-plugins-reveal A more advanced mindmap with formatting, code blocks, and math:\n```markmap\r- Mindmaps\r- Links\r- [Wowchemy Docs](https://wowchemy.com/docs/)\r- [Discord Community](https://discord.gg/z8wNYzb)\r- [GitHub](https://github.com/wowchemy/wowchemy-hugo-themes)\r- Features\r- Markdown formatting\r- **inline** ~~text~~ *styles*\r- multiline\rtext\r- `inline code`\r-\r```js\rconsole.log(\u0026#39;hello\u0026#39;);\rconsole.log(\u0026#39;code block\u0026#39;);\r```\r- Math: $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$\r```\rrenders as\n- Mindmaps\r- Links\r- [Wowchemy Docs](https://wowchemy.com/docs/)\r- [Discord Community](https://discord.gg/z8wNYzb)\r- [GitHub](https://github.com/wowchemy/wowchemy-hugo-themes)\r- Features\r- Markdown formatting\r- **inline** ~~text~~ *styles*\r- multiline\rtext\r- `inline code`\r-\r```js\rconsole.log(\u0026#39;hello\u0026#39;);\rconsole.log(\u0026#39;code block\u0026#39;);\r```\r- Math: $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$ Charts Wowchemy supports the popular Plotly format for interactive charts.\nSave your Plotly JSON in your page folder, for example line-chart.json, and then add the {{\u0026lt; chart data=\u0026#34;line-chart\u0026#34; \u0026gt;}} shortcode where you would like the chart to appear.\nDemo:\nYou might also find the Plotly JSON Editor useful.\nMath Wowchemy supports a Markdown extension for $\\LaTeX$ math. You can enable this feature by toggling the math option in your config/_default/params.yaml file.\nTo render inline or block math, wrap your LaTeX math with {{\u0026lt; math \u0026gt;}}$...${{\u0026lt; /math \u0026gt;}} or {{\u0026lt; math \u0026gt;}}$$...$${{\u0026lt; /math \u0026gt;}}, respectively. (We wrap the LaTeX math in the Wowchemy math shortcode to prevent Hugo rendering our math as Markdown. The math shortcode is new in v5.5-dev.)\nExample math block:\n{{\u0026lt; math \u0026gt;}} $$ \\gamma_{n} = \\frac{ \\left | \\left (\\mathbf x_{n} - \\mathbf x_{n-1} \\right )^T \\left [\\nabla F (\\mathbf x_{n}) - \\nabla F (\\mathbf x_{n-1}) \\right ] \\right |}{\\left \\|\\nabla F(\\mathbf{x}_{n}) - \\nabla F(\\mathbf{x}_{n-1}) \\right \\|^2} $$ {{\u0026lt; /math \u0026gt;}} renders as\n$$\\gamma_{n} = \\frac{ \\left | \\left (\\mathbf x_{n} - \\mathbf x_{n-1} \\right )^T \\left [\\nabla F (\\mathbf x_{n}) - \\nabla F (\\mathbf x_{n-1}) \\right ] \\right |}{\\left \\|\\nabla F(\\mathbf{x}_{n}) - \\nabla F(\\mathbf{x}_{n-1}) \\right \\|^2}$$\rExample inline math {{\u0026lt; math \u0026gt;}}$\\nabla F(\\mathbf{x}_{n})${{\u0026lt; /math \u0026gt;}} renders as $\\nabla F(\\mathbf{x}_{n})$.\nExample multi-line math using the math linebreak (\\\\):\n{{\u0026lt; math \u0026gt;}} $$f(k;p_{0}^{*}) = \\begin{cases}p_{0}^{*} \u0026amp; \\text{if }k=1, \\\\ 1-p_{0}^{*} \u0026amp; \\text{if }k=0.\\end{cases}$$ {{\u0026lt; /math \u0026gt;}} renders as\n$$\rf(k;p_{0}^{*}) = \\begin{cases}p_{0}^{*} \u0026amp; \\text{if }k=1, \\\\\r1-p_{0}^{*} \u0026amp; \\text{if }k=0.\\end{cases}\r$$\rDiagrams Wowchemy supports a Markdown extension for diagrams. You can enable this feature by toggling the diagram option in your config/_default/params.toml file or by adding diagram: true to your page front matter.\nAn example flowchart:\n```mermaid\rgraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2]\r```\rrenders as\ngraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2] An example sequence diagram:\n```mermaid\rsequenceDiagram\rAlice-\u0026gt;\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts!\rJohn--\u0026gt;\u0026gt;Alice: Great!\rJohn-\u0026gt;\u0026gt;Bob: How about you?\rBob--\u0026gt;\u0026gt;John: Jolly good!\r```\rrenders as\nsequenceDiagram\rAlice-\u0026gt;\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts!\rJohn--\u0026gt;\u0026gt;Alice: Great!\rJohn-\u0026gt;\u0026gt;Bob: How about you?\rBob--\u0026gt;\u0026gt;John: Jolly good! An example Gantt diagram:\n```mermaid\rgantt\rsection Section\rCompleted :done, des1, 2014-01-06,2014-01-08\rActive :active, des2, 2014-01-07, 3d\rParallel 1 : des3, after des1, 1d\rParallel 2 : des4, after des1, 1d\rParallel 3 : des5, after des3, 1d\rParallel 4 : des6, after des4, 1d\r```\rrenders …","date":1562889600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1562889600,"objectID":"07e02bccc368a192a0c76c44918396c3","permalink":"https://hzyzh.github.io/post/writing-technical-content/","publishdate":"2019-07-12T00:00:00Z","relpermalink":"/post/writing-technical-content/","section":"post","summary":"Wowchemy is designed to give technical content creators a seamless experience. You can focus on the content and Wowchemy handles the rest.\nHighlight your code snippets, take notes on math classes, and draw diagrams from textual representation.","tags":null,"title":"Writing technical content in Markdown","type":"post"},{"authors":["Zeyu Huang"],"categories":null,"content":" Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://hzyzh.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Wowchemy Wowchemy | Documentation\nFeatures Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides Controls Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026#34;blueberry\u0026#34; if porridge == \u0026#34;blueberry\u0026#34;: print(\u0026#34;Eating...\u0026#34;) Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}} Press Space to play!\nOne Two Three A fragment can accept two optional parameters:\nclass: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}} Press the S key to view the speaker notes!\nOnly the speaker can read these notes Press S key to view Themes black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026#34;/media/boards.jpg\u0026#34; \u0026gt;}} {{\u0026lt; slide background-color=\u0026#34;#0000FF\u0026#34; \u0026gt;}} {{\u0026lt; slide class=\u0026#34;my-style\u0026#34; \u0026gt;}} Custom CSS Example Let’s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; } Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://hzyzh.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Wowchemy's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"e8f8d235e8e7f2efd912bfe865363fc3","permalink":"https://hzyzh.github.io/project/example/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/example/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Example Project","type":"project"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://hzyzh.github.io/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":["Zeyu Huang","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://hzyzh.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["Zeyu Huang","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software. Create your slides in Markdown - click the Slides button to check out the example. Supplementary notes can be added here, including code, math, and images.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://hzyzh.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":[],"title":"An example conference paper","type":"publication"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a8edef490afe42206247b6ac05657af0","permalink":"https://hzyzh.github.io/talk/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/talk/","section":"event","summary":"","tags":null,"title":"","type":"event"}]